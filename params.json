{
  "name": "Proof-of-individuality",
  "tagline": "The Proof-of-Individuality (POI) protocol is a fully anonymous anti-sybil protocol ",
  "body": "### Randomized pseudonym parties using video hangouts\r\n\r\n```\r\ncontract poi {\r\n    \r\n    bool debug;\r\n    uint blockNum;\r\n\r\n    uint groupSize;\r\n    bytes32 entropy;\r\n    \r\n    uint public numUsers;\r\n    mapping(address => bytes32) public userHash;\r\n    //mapping(bytes32 => address) public userAddress;\r\n    mapping(address => uint) public userGroup;\r\n\r\n    // max value of a sha3 hash\r\n    bytes32 maxHash = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    \r\n    enum Phases { Registration, Commitment, Verification } \r\n    event Registration(bytes32 userHash);\r\n    event Commitment(bytes32 userHash, uint group);\r\n    event Verification(bytes32 userHash);\r\n\r\n    Phases phase;\r\n    uint public genesisBlock;\r\n    uint public registrationBlock;\r\n    uint public commitmentBlock;\r\n    uint public validityBlock;\r\n    \r\n    function blockNumber() constant returns(uint){ if (debug) { return blockNum; } return block.number; }\r\n    function numGroups() constant returns(uint){ return numUsers / groupSize;}\r\n    \r\n    function poi(){\r\n        debug = true;\r\n        groupSize = 5;\r\n        entropy = sha3(block.blockhash(block.number));\r\n        genesisBlock = block.number;\r\n        registrationBlock = genesisBlock + 7;\r\n        commitmentBlock = registrationBlock + 3;\r\n        validityBlock = commitmentBlock + 20;\r\n        phase = Phases.Registration;\r\n    }\r\n    \r\n    function register() returns(bool success){\r\n        if ((blockNumber() > registrationBlock) // registation period over\r\n        || (userHash[msg.sender] != bytes32(0))) return; // already registered\r\n        \r\n        // generate a hash for the given user, using previous entropy, \r\n        // senders address and current blocknumber.\r\n        bytes32 h = sha3(entropy, msg.sender, block.blockhash(block.number));\r\n        entropy = h;\r\n        userHash[msg.sender] = h;\r\n        //userAddress[h] = msg.sender;\r\n        numUsers++;\r\n        Registration(h);\r\n        return true;\r\n    }\r\n    \r\n    function commit() returns(bool success){\r\n        if ((blockNumber() < registrationBlock) // registation period not yet over\r\n        || (blockNumber() > commitmentBlock) // commitment period over\r\n        || (userGroup[msg.sender] != 0)) return; // group already assigned\r\n\r\n        phase = Phases.Commitment;\r\n        \r\n        // deterministically assign user to random group (1-indexed)\r\n        // based on number of users, group size and user hash;\r\n        userGroup[msg.sender] = uint(userHash[msg.sender]) / (uint(maxHash) / numGroups()) + 1;\r\n        Commitment(userHash[msg.sender], userGroup[msg.sender]);\r\n        return true;\r\n    }\r\n    \r\n    function verify(bytes32 data, uint8 v, bytes32 r, bytes32 s ) returns(bool success){\r\n        if ((blockNumber() < commitmentBlock) // commitment period not yet over\r\n        || (blockNumber() > validityBlock) // verification period over\r\n        || (userGroup[msg.sender] == 0)) return;\r\n\r\n        phase = Phases.Verification;\r\n        \r\n        // TODO :)\r\n        address signer = ecrecover( data, v, r, s);\r\n        // is the proof provided by a user in the same group\r\n        if (userGroup[signer] == userGroup[msg.sender]) {\r\n            Verification(userHash[msg.sender]);\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    function _incBlock() { if (debug) blockNum++; }\r\n    function _myAddressHelper() constant returns(address){ return msg.sender; }\r\n    function _myGroupHelper() constant returns(uint group) {\r\n        return userGroup[msg.sender];\r\n    }\r\n    \r\n}\r\n```\r\n\r\n### Anonymous and untraceable POI tokens\r\n```\r\n/* component of the Proof-of-individuality (POI) system. Generates new POIs each month, anonymous and un-traceable */\r\n\r\ncontract generatePOItokens{\r\n    address owner;\r\n  \r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    \r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function generatePOItokens(address[] verifiedUsers) {\r\n        owner = msg.sender;\r\n        balanceOf[owner] = verifiedUsers.length;            // Give the creator all initial tokens                    \r\n        name = \"POI\";                                       // Set the name for display purposes     \r\n        symbol = \"POI\";                                     // Set the symbol for display purposes    \r\n        decimals = 0;                                       // Amount of decimals for display purposes        \r\n    \r\n      /* Send POIs to every verified address */\r\n\r\n        for (uint i = 0; i < verifiedUsers.length; i++)\r\n           balanceOf[owner] -= 1;                                              \r\n           balanceOf[verifiedUsers[i]] += 1;\r\n           Transfer(owner, verifiedUsers[i], 1);            // Notify anyone listening that this transfer took place\r\n    }\r\n\r\n    \r\n    function depricatePOIs() {\r\n     if (msg.sender == owner) suicide(owner);\r\n    }\r\n    \r\n}\r\n\r\ncontract POIscheduler{\r\n\r\naddress[] verifiedUsers;\r\naddress POIaddress;\r\n\r\nuint public genesisblock;\r\nuint public roundLength;\r\nuint public nextRound;\r\n\r\n    function POIscheduler(){\r\n    owner = msg.sender;\r\n    genesisblock = block.number;\r\n    roundLength = 3000; // set POI pseudonym parties to happen once a month\r\n    nextRound = genesisblock + roundLength;\r\n    scheduleCall();\r\n    }\r\n    \r\n    function issuePOIs() {\r\n    \tif(block.number<nextRound)\r\n    \t\tthrow;\r\n        // depricate old POIs\r\n        generatePOItokens(POIaddress).depricatePOIs();\r\n    \r\n        POIaddress = new generatePOItokens(verifiedUsers);\r\n        \r\n        /* schedule a new POI round one month from now */\r\n        \r\n        nextRound += roundLength;\r\n        scheduleCall();\r\n    }\r\n   \r\n\r\n    function scheduleCall() public {\r\n    \r\n     /* ethereum-alarm-clock is a DAO for excecuting scheduled calls */\r\n     \r\n    \taddress scheduler = 0x26416b12610d26fd31d227456e9009270574038f; // alarm service v0.7 on the morden testnet\r\n\r\n        // the 4-byte signature of the local function we want to be called.\r\n        bytes4 sig = bytes4(sha3(\"issuePOIs()\"));\r\n\r\n        // approximately 1 month from now\r\n        uint targetBlock = nextRound;\r\n\r\n        // the 4-byte signature of the scheduleCall function.\r\n        bytes4 scheduleCallSig = bytes4(sha3(\"scheduleCall(bytes4,uint256)\"));\r\n\r\n        scheduler.call(scheduleCallSig, sig, targetBlock);\r\n    }\r\n\r\n    function verifyPOI (address v) constant returns (string){\r\n\tif (generatePOItokens(POIaddress).balanceOf[v]==0){\r\n\t\treturn \"account does not have a valid POI\";\r\n\t}\r\n\treturn \"account has a valid POI\";\r\n    }   \r\n   \r\n}\r\n```\r\n\r\n### Anti-Sybil Fuel (ASF)\r\n![](http://i.imgur.com/M138htP.png)\r\n```\r\n/* \r\nAnti-sybil fuel (ASF) is used to gamify the POI hangouts. Participants can \r\nuse it to \"hijack each other's attention\", which makes it easier for the \r\nPOI community to keep high standards. Each user gets 5000 \"anti-sybil fuel\" points, \r\nand then rewards the other 4 users for their attention. This makes it possible \r\nfor 4 people to put peer-pressure on the 5th if the 5th person isn't focused \r\non the joint attention test. \r\n*/\r\n\r\ncontract AntiSybilFuel { \r\n\r\n\r\n    struct ASF {\r\n        uint256 initial_supply;\r\n        uint256 rewarded;\r\n        uint256 given;\r\n    }\r\n    \r\n    mapping (address => ASF) public ASFbalances;\r\n    \r\n    function AntiSybilFuel(address[] hangoutGroup) {\r\n        \r\n        for (uint i = 0; i < hangoutGroup.length; i++)\r\n            ASFbalances[hangoutGroup[i]].initial_supply += 5000;\r\n    }\r\n    \r\n    function rewardASF(address _to, uint256 _value) {\r\n\r\n    /* If the sent amount is bigger than the maximum amount one can give, send max amount */\r\n        if (ASFbalances[msg.sender].given + _value >5000)\r\n        _value = _value-((ASFbalances[_to].rewarded+_value)-5000);\r\n\r\n    /* If the sent amount is bigger than the maximum reward limit, send max amount */\r\n        if (ASFbalances[_to].rewarded + _value >5000)\r\n        _value = _value-((ASFbalances[_to].rewarded+_value)-5000);\r\n       \r\n    /* transfer the anti sybil fuel */\r\n        ASFbalances[msg.sender].given +=_value;\r\n        ASFbalances[_to].rewarded +=_value;\r\n   } \r\n    \r\n   /* after 15 minutes, each users that has been awarded 4000 ASF or more, and \r\n      given out 4000 or more, is seen as verified and given a POI token */\r\n\r\n   function verification(){\r\n       */ do checkup */\r\n       */ generate POIs, see contract generatePOItokens */\r\n   }\r\n\r\n\r\n\r\n}            \r\n```",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}